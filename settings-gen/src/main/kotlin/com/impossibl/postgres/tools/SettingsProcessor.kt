package com.impossibl.postgres.tools

import com.impossibl.postgres.tools.SettingsProcessor.Companion.SETTING_TYPE_NAME
import com.squareup.javapoet.*
import java.io.FileOutputStream
import java.io.OutputStreamWriter
import java.io.StringWriter
import java.nio.charset.Charset
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.function.Function
import javax.annotation.processing.*
import javax.lang.model.SourceVersion.RELEASE_8
import javax.lang.model.element.*
import javax.lang.model.type.DeclaredType
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.Elements
import javax.lang.model.util.Types
import javax.tools.Diagnostic


@SupportedAnnotationTypes(
   "$SETTING_TYPE_NAME.Factory"
)
@SupportedSourceVersion(RELEASE_8)
class SettingsProcessor : AbstractProcessor() {

  data class GroupInfo(val id: String, val desc: String, val global: Boolean,
                       val field: VariableElement)

  data class SettingInfo(val name: String, val group: String, val type: TypeMirror,
                         val desc: String, val default: String?, val defaultDynamic: Boolean,
                         val alternateNames: List<String>?,
                         val field: VariableElement)

  companion object {

    private const val PG_PKG = "com.impossibl.postgres"
    private const val SYSTEM_PKG = "$PG_PKG.system"
    private const val JDBC_PKG = "$PG_PKG.jdbc"
    const val SETTING_TYPE_NAME = "$SYSTEM_PKG.Setting"
    const val SETTING_TYPE_ANN_NAME = "$SETTING_TYPE_NAME.Info"
    const val SETTING_GROUP_TYPE_NAME = "$SETTING_TYPE_NAME.Group"
    const val SETTING_GROUP_TYPE_ANN_NAME = "$SETTING_GROUP_TYPE_NAME.Info"

    const val JDBC_DS_GROUP_NAME = "jdbc-ds"
    const val SYSTEM_PROPERTY_PREFIX = "pgjdbc."

  }

  private lateinit var types: Types
  private lateinit var elements: Elements
  private lateinit var filer: Filer
  private lateinit var messager: Messager

  private var generatedAnn: TypeElement? = null
  private lateinit var factoryAnn: TypeElement
  private lateinit var descriptionAnn: TypeElement
  private lateinit var descriptionAnnType: TypeMirror
  private lateinit var settingType: TypeMirror
  private lateinit var settingGroupType: TypeMirror
  private lateinit var settingAnn: TypeElement
  private lateinit var settingAnnType: TypeMirror
  private lateinit var settingGroupAnn: TypeElement
  private lateinit var settingGroupAnnType: TypeMirror

  private val converterTypeName = ClassName.get(SYSTEM_PKG, "Setting", "Converter")
  private val funcTypeName = ClassName.get(Function::class.java)
  private val versionTypeName = ClassName.get(SYSTEM_PKG, "Version")
  private val strTxmsTypeName = ClassName.get("$PG_PKG.utils", "StringTransforms")
  private val dsTypeName = ClassName.get(JDBC_PKG, "AbstractDataSource")

  override fun init(processingEnv: ProcessingEnvironment) {
    synchronized(this) {
      super.init(processingEnv)

      types = processingEnv.typeUtils
      elements = processingEnv.elementUtils
      filer = processingEnv.filer
      messager = processingEnv.messager
    }
  }

  override fun process(annotations: MutableSet<out TypeElement>, roundEnv: RoundEnvironment): Boolean {

    cacheElementsAndTypes()

    val (groups, settings) = gatherSettingsAndGroups(roundEnv)
    if (groups.isEmpty() && settings.isEmpty()) return true

    if (!validate(groups, settings)) return false

    if (!generateSettingInitializer(groups, settings)) return false

    val globalGroups = groups.filter { it.global }.toSet()

    if (!generateDataSourceWithProperties(globalGroups, settings)) return false

    if (!generateSettingsDoc(globalGroups, settings)) return false

    return true
  }

  private fun cacheElementsAndTypes() {
    generatedAnn =
       elements.getTypeElement("javax.annotation.processing.Generated") ?:
       elements.getTypeElement("javax.annotation.Generated")
    factoryAnn = elements.getTypeElement("$SETTING_TYPE_NAME.Factory")
    descriptionAnn = elements.getTypeElement("$SETTING_TYPE_NAME.Description")
    descriptionAnnType = descriptionAnn.asType()
    settingType = elements.getTypeElement(SETTING_TYPE_NAME).asType()
    settingAnn = elements.getTypeElement(SETTING_TYPE_ANN_NAME)
    settingAnnType = settingAnn.asType()
    settingGroupType = elements.getTypeElement(SETTING_GROUP_TYPE_NAME).asType()
    settingGroupAnn = elements.getTypeElement(SETTING_GROUP_TYPE_ANN_NAME)
    settingGroupAnnType = settingGroupAnn.asType()
  }

  private fun generateSettingsDoc(groups: Set<GroupInfo>, settings: Set<SettingInfo>): Boolean {

    OutputStreamWriter(FileOutputStream("./SETTINGS.md"))
       .use { out ->

         out.append(
                 "NOTE: This file is autogenerated from code based on `Setting` & `Setting.Group`. If there are " +
                 "any errors or omissions they need to be addressed in code; not by editing this file.\n\n"
         )

         for (group in groups) {

           out.append("## ").append(group.desc)
              .append("\n\n")

           for (setting in settings) {
             if (setting.group != group.id) continue

             out.append("#### ").append(setting.name.toTitleCase())
                .append("\n\n")

             out.append(setting.desc.escapeMarkdown())
                .append("\n\n")

             if (setting.type.isEnum) {
               val enumElement = (setting.type as? DeclaredType)!!.asElement() as TypeElement
               out.append(enumDocumentation(enumElement))
                  .append("\n\n")
             }

             if (group.id != JDBC_DS_GROUP_NAME) {
               out.append("Driver Property: `").append(setting.name).append("`")
                  .append("\n\n")
             }

             val typeName = ClassName.get(setting.type)

             out.append("DataSource: ")
                .append("`get").append(setting.name.beanPropertyName.capitalize()).append("()`/")
                .append("`set").append(setting.name.beanPropertyName.capitalize()).append("(").append(typeName.toString()).append(")`")
                .append("\n\n")

             out.append("System Property: `").append(SYSTEM_PROPERTY_PREFIX).append(
                setting.name).append("`")
                .append("\n\n")

             if (!setting.defaultDynamic) {
               val default =
                  if (setting.default != null)
                    if (!setting.default.isEmpty())
                      "`${setting.default}`"
                    else
                      "Empty"
                  else
                    "None"
               out.append("Default: ").append(default)
                  .append("\n\n")
             }
           }

         }

       }

    return true
  }

  private fun generateSettingInitializer(groups: Set<GroupInfo>, settings: Set<SettingInfo>): Boolean {

    val initClassBldr = TypeSpec.classBuilder("SettingInitializer")
       .addModifiers(Modifier.PUBLIC)
       .apply {
         if (generatedAnn != null) {
           addAnnotation(
              AnnotationSpec.builder(ClassName.get(generatedAnn))
                 .addMember("value", "{\$S, \$S}",
                            SettingsProcessor::class.java.canonicalName,
                            "PGJDBC-NG Settings Annotation Processor")
                 .addMember("date", "\$S", DateTimeFormatter.ISO_DATE_TIME.format(LocalDateTime.now()))
                 .addMember("comments", "\$S", "Generated from Setting(s) defined in the all Setting.Group(s)")
                 .build()
           )
         }
       }

    val staticCode = CodeBlock.builder()

    for (group in groups) {

      val ownerTypeName = ClassName.get(group.field.enclosingElement.asType())
      val groupFieldName = group.field.simpleName.toString()

      staticCode.addStatement("\$T.\$L.init(\$S, \$S, \$L)", ownerTypeName, groupFieldName, group.id, group.desc,
                              group.global)
    }

    for (setting in settings) {

      val ownerTypeName = ClassName.get(setting.field.enclosingElement.asType())
      val settingFieldName = setting.field.simpleName.toString()
      val settingTypeName = TypeName.get(setting.type)

      val fromString = CodeBlock.builder()
      val toString = CodeBlock.builder()

      when (settingTypeName) {

        ClassName.get(java.lang.String::class.java) -> {
          fromString.add("\$T.identity()", converterTypeName)
          toString.add("\$T.identity()", funcTypeName)
        }

        ClassName.get(java.lang.Integer::class.java) -> {
          fromString.add("\$T::parseInt", settingTypeName)
          toString.add("\$T::toString", TypeName.OBJECT)
        }

        ClassName.get(java.lang.Boolean::class.java) -> {
          fromString.add("\$T::parseBoolean", settingTypeName)
          toString.add("\$T::toString", TypeName.OBJECT)
        }

        ClassName.get(Charset::class.java) -> {
          fromString.add("\$T::forName", settingTypeName)
          toString.add("\$T::name", settingTypeName)
        }

        ClassName.get(java.lang.Class::class.java) -> {
          fromString.add("\$T::forName", settingTypeName)
          toString.add("\$T::getName", settingTypeName)
        }

        versionTypeName -> {
          fromString.add("\$T::parse", versionTypeName)
          toString.add("\$T::toString", versionTypeName)
        }

        else ->

          if (setting.type.isEnum) {

            if (setting.type.isEnumUpperSnakeCase) {

              fromString.add("str -> \$T.valueOf(\$T.class, \$T.toUpperSnakeCase(str))",
                             ClassName.get(java.lang.Enum::class.java), settingTypeName, strTxmsTypeName)
              toString.add("e -> \$T.dashedFromSnakeCase(e.name())", strTxmsTypeName)
            }
            else {

              fromString.add("str -> \$T.valueOf(\$T.class, \$T.toUpperCamelCase(str))",
                             ClassName.get(java.lang.Enum::class.java), settingTypeName, strTxmsTypeName)
              toString.add("e -> \$T.dashedFromCamelCase(e.name())", strTxmsTypeName)
            }
          }
          else {
            messager.printMessage(Diagnostic.Kind.ERROR, "Unsupported Setting Type", setting.field)
            return false
          }
      }

      val names = listOf(setting.name) + (setting.alternateNames ?: emptyList())

      staticCode.addStatement("\$T.\$L.init(\$S, \$S, \$S, \$L, \$T.class, \$L, \$L, new String[] {\$L})",
                              ownerTypeName, settingFieldName,
                              setting.group, setting.desc.escapePoet(), setting.default, setting.defaultDynamic,
                              settingTypeName, fromString.build(), toString.build(),
                              names.joinToString { """"$it"""" })
    }

    initClassBldr.addStaticBlock(staticCode.build())

    val factoryElements =
       groups.map { it.field.enclosingElement }.toSet() + settings.map { it.field.enclosingElement }.toSet()

    for (factoryElement in factoryElements) {

      initClassBldr.addMethod(
         MethodSpec.methodBuilder("init${factoryElement.simpleName.toString().capitalize()}")
            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
            .build()
      )

    }

    JavaFile.builder(SYSTEM_PKG, initClassBldr.build())
       .skipJavaLangImports(true)
       .build()
       .writeTo(filer)

    return true
  }

  private fun generateDataSourceWithProperties(groups: Set<GroupInfo>, settings: Set<SettingInfo>): Boolean {

    val groupIds = groups.map { it.id }.toSet()

    val dsClassBldr = TypeSpec.classBuilder("AbstractGeneratedDataSource")
       .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
       .superclass(dsTypeName)
       .apply {
         if (generatedAnn != null) {
           addAnnotation(
              AnnotationSpec.builder(ClassName.get(generatedAnn))
                 .addMember("value", "{\$S, \$S}",
                            SettingsProcessor::class.java.canonicalName,
                            "PGJDBC-NG Settings Annotation Processor")
                 .addMember("date", "\$S", DateTimeFormatter.ISO_DATE_TIME.format(LocalDateTime.now()))
                 .addMember("comments", "\$S", "Generated from Setting(s) defined in the global Setting.Group(s)")
                 .build()
           )
         }
       }
       .addAnnotation(
          AnnotationSpec.builder(SuppressWarnings::class.java)
             .addMember("value", "{\$S, \$S}", "unused", "WeakerAccess")
             .build()
       )

    val added = mutableSetOf<SettingInfo>()

    for (setting in settings) {
      if (!groupIds.contains(setting.group)) continue

      if (added.contains(setting)) continue
      added.add(setting)

      val typeName = ClassName.get(setting.type)
      val owner = ClassName.get(setting.field.enclosingElement.asType())

      val paramType =
         if (typeName.isPrimitive || typeName.isBoxedPrimitive)
           setting.type
         else
           elements.getTypeElement(String::class.java.canonicalName).asType()

      val paramTypeName = ClassName.get(paramType)

      val getterTypeName =
         if (!setting.defaultDynamic && setting.default != null && paramTypeName.isBoxedPrimitive)
           paramTypeName.unbox()
         else
           paramTypeName

      val settingsGetterName = if (paramType != setting.type) "getText" else "get"

      val getter = MethodSpec.methodBuilder("get" + setting.name.beanPropertyName.capitalize())
         .addJavadoc(setting.desc.escapePoet() + "\n\n")
         .addJavadoc("@see #set\$L\n", setting.name.beanPropertyName.capitalize())
         .addJavadoc("@return Current value of \$L\n", setting.name.beanPropertyName)
         .addModifiers(Modifier.PUBLIC)
         .returns(getterTypeName)
         .addCode(
            CodeBlock.builder()
               .addStatement("return settings.\$L(\$T.\$L)", settingsGetterName, owner,
                             setting.field.simpleName.toString())
               .build()
         )

      dsClassBldr.addMethod(getter.build())

      val setterTypeName =
         if (paramTypeName.isBoxedPrimitive)
           paramTypeName.box()
         else
           paramTypeName

      val settingsSetterName = if (paramType != setting.type) "setText" else "set"

      val setter = MethodSpec.methodBuilder("set" + setting.name.beanPropertyName.capitalize())
         .addJavadoc(setting.desc.escapePoet() + "\n\n")
         .apply {
           if (setting.type.isEnum) {
             val enumElement = (setting.type as? DeclaredType)!!.asElement() as TypeElement
             addJavadoc(enumDocumentation(enumElement) + "\n\n")
           }
         }
         .addJavadoc("@param \$L New value of \$L\n", setting.name.beanPropertyName, setting.name.beanPropertyName)
         .addModifiers(Modifier.PUBLIC)
         .addParameter(setterTypeName, setting.name.beanPropertyName)
         .addCode(
            CodeBlock.builder()
               .addStatement("settings.\$L(\$T.\$L, \$L)", settingsSetterName, owner,
                             setting.field.simpleName.toString(), setting.name.beanPropertyName)
               .build()
         )

      dsClassBldr.addMethod(setter.build())
    }

    val dsClass = dsClassBldr.build()

    JavaFile.builder("com.impossibl.postgres.jdbc", dsClass)
       .skipJavaLangImports(true)
       .build()
       .writeTo(filer)

    return true
  }

  private fun enumDocumentation(element: TypeElement): String {

    val valueFormatter: (String) -> String =
       if (element.asType().isEnumUpperSnakeCase)
        String::dashesFromSnakeCase
       else
        String::dashesFromCamelCase

    return StringWriter()
       .use { out ->

         out.append("<ul>\n")

         for (enumConst in element.enclosedElements.filter { it.kind == ElementKind.ENUM_CONSTANT }) {

           val value = enumConst.simpleName.toString()

           out.append(" <li>\n")
              .append("  <code>").append(valueFormatter(value)).append("</code>")

           val description = enumConst.annotationMirrors.firstOrNull { it.annotationType == descriptionAnnType }
           if (description != null) {
             val descriptionValue = description.elementValues.values.first().value as String
             out.append(" - \n   ").append(descriptionValue.trim().replace("\n", "\n   ")).append("\n")
           }

           out.append(" </li>")
              .append("\n")


         }

         out.append("</ul>\n")
       }
       .toString()
  }

  private fun validate(groups: Set<GroupInfo>, settings: Set<SettingInfo>): Boolean {

    var valid = true
    val globalSettingNames = mutableSetOf<String>()

    for (setting in settings) {

      // Check that setting references a defined group

      val group = groups.find { it.id == setting.group }
      if (group == null) {
        messager.printMessage(Diagnostic.Kind.ERROR, "Setting '${setting.name}' references undefined group '${setting.group}'", setting.field)
        valid = false
        continue
      }

      // If global, check name is unique

      if (group.global && globalSettingNames.contains(setting.name)) {
        messager.printMessage(Diagnostic.Kind.ERROR, "Setting name '${setting.name}' is duplicated", setting.field)
        valid = false
        continue
      }
      globalSettingNames.add(setting.name)


    }

    return valid
  }

  private fun gatherSettingsAndGroups(roundEnv: RoundEnvironment): Pair<Set<GroupInfo>, Set<SettingInfo>> {

    val groups = linkedSetOf<GroupInfo>()
    val settings = linkedSetOf<SettingInfo>()

    for (factoryElement in roundEnv.getElementsAnnotatedWith(factoryAnn)) {

      for (fieldElement in factoryElement.enclosedElements.filter { it.kind == ElementKind.FIELD }) {
        if (fieldElement !is VariableElement) continue

        if (fieldElement.isSetting) {

          val settingFieldType = fieldElement.asType() as? DeclaredType ?: continue

          val settingInfo =
             fieldElement.annotationMirrors.firstOrNull { it.annotationType == settingAnnType } ?: continue

          val settingType = settingFieldType.typeArguments.first()

          val elementValues = settingInfo.elementValues

          val settingName = elementValues[settingAnn.getAnnotationMethod("name")]!!.value as String
          val settingGroup = elementValues[settingAnn.getAnnotationMethod("group")]!!.value as String
          val settingDesc = elementValues[settingAnn.getAnnotationMethod("desc")]!!.value as String
          val settingDef = elementValues[settingAnn.getAnnotationMethod("def")]?.value as? String
          val settingDyn = elementValues[settingAnn.getAnnotationMethod("dynamic")]?.value as? Boolean
          @Suppress("UNCHECKED_CAST") val settingAlts =
             (elementValues[settingAnn.getAnnotationMethod("alternateNames")]?.value as? List<AnnotationValue>)?.map { it.value } as? List<String>

          settings.add(SettingInfo(settingName, settingGroup, settingType, settingDesc,
                                   settingDef, settingDyn ?: false,
                                   settingAlts,
                                   fieldElement))
        }
        else if (fieldElement.isSettingGroup) {

          val groupInfo =
             fieldElement.annotationMirrors.firstOrNull { it.annotationType == settingGroupAnnType } ?: continue

          val elementValues = elements.getElementValuesWithDefaults(groupInfo)

          val groupId = elementValues[settingGroupAnn.getAnnotationMethod("id")]!!.value as String
          val groupDesc = elementValues[settingGroupAnn.getAnnotationMethod("desc")]!!.value as String
          val groupGlobal = elementValues[settingGroupAnn.getAnnotationMethod("global")]!!.value as Boolean

          groups.add(GroupInfo(groupId, groupDesc, groupGlobal, fieldElement))
        }

      }

    }

    return groups to settings
  }

  private val TypeMirror.isEnum: Boolean get() {
    return (this as? DeclaredType)?.asElement()?.kind == ElementKind.ENUM
  }

  private val VariableElement.isSetting: Boolean get() {
    return types.erasure(asType()) == types.erasure(settingType)
  }

  private val VariableElement.isSettingGroup: Boolean get() {
    return asType() == settingGroupType
  }

  private fun TypeElement.getAnnotationMethod(name: String): ExecutableElement {
    return enclosedElements
       .filter { it.kind == ElementKind.METHOD }
       .firstOrNull { it.simpleName.contentEquals(name) } as ExecutableElement
  }

  private val TypeMirror.isEnumUpperSnakeCase: Boolean get() {
    return (this as DeclaredType).asElement().enclosedElements
       .filter { it.kind == ElementKind.ENUM_CONSTANT }
       .all { it.simpleName.toString().matches("""[A-Z_]+""".toRegex()) }
  }

}
