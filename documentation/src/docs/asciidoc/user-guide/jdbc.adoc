[[jdbc]]
== JDBC 4.2

There are numerous JDBC books, tutorials, blogs, etc. available to learn the basics and even advanced aspects of
JDBC. As such, this section will provide details only specific to easy and efficient usage of {drivername}'s
implementation of the JDBC specification.

[[jdbc-extended-types]]
=== Using Specific {vendorname} Types

JDBC maps many of the stand SQL types to JDBC types and further to Java classes. Prior to JDBC 4.2 this was
done using an integer type code (available in `java.sql.Types`). This mapping proves lacking when it comes to
using many of the extended types that {vendorname} provides.

JDBC 4.2 added a new method for specifying extended types, `java.sql.SQLType`. Most of the interfaces in JDBC
were extended to accept this new, extendable, type in place of the previous integer type code. {drivername} has
embraced this new method of using/specfiying {vendorname}'s extended types via `PGTYpe`.

==== PGType

PGType is a {drivername} provided implementation of `java.sql.SQLType` and allows referencing the most common
of the specific {vendorname} extended types using a simple enum.

PGType can be used wherever a `java.sql.SQLType` is accepted and whenever a specific {vendorname} type is
wanted or required.

[source,java]
.Setting a parameter value, specifying {vendorname}'s money type
----
PreparedStatement pstmt = connection.prepareStatement("INSERT INTO ledger(balance) VALUES (?)");
pstmt.setObject(1, 113.54, PGType.MONEY); <1>
pstmt.executeUpdate();
----
<1> Set a `float` with the specific column type of `money`.

==== Resolving Custom Types

As stated, PGType only handles the most common of {vendorname}'s types. Any extended types not supported
by PGType must be handled by resolving a type name to a `PGAnyType`.

`PGConnection` provides the `resolveType` method which does the resolution to a `PGAnyType` and thus
provides usable ``SQLType``s.

[source,java]
.Resolving a type to a PGAnyType
----
PGConnection pgConnection = connection.unwrap(PGConnection.class); <1>
PGAnyType myType = pgConnection.resolveType("my_type"); <2>
----
<1> Acquire a `PGConnection` from a standard connection (see <<extensions-pgconnection-access>>).
<2> Resolve the custom type `my_type` to a `PGAnyType`.


[[jdbc-user-types]]
=== User Defined Types

{vendorname} supports User Defined Types, what it refers to as composite types, created with the
`CREATE TYPE <name> AS (<attributes>)` DDL. These are supported in JDBC using one of two mechanisms,
the standard `java.sql.Struct` API or via custom mapped Java classes that implement `java.sql.SQLData`.

==== java.sql.Struct

{drivername} fully supports UDTs via the JDBC `java.sql.Struct` API for specifying and UDT parameters
and for retrieving UDT values in from ``ResultSet``s.

==== java.sql.SQLData

Alternatively to using the standard Struct interface to access UDTs, custom Java classes can be created
that implement the `java.sql.SQLData` interface.  {drivername} also fully supports the `java.sql.SQLData`
API.

===== Creating custom types

The JDBC specification _suggests_ that all classes implementing `SQLData` be generated by a mechanism of the
implementation's choosing. {drivername} supports this method using the provided <<udt-generator>>, although
UDTs can also be created manually.

====== UDT Generator

Using the UDT generator requires a running {vendorname} instance and a schema in place that provides the
types that Java classes are to be generated for.  Details about executing the UDT generator, either via the
command line interface or using it as a Java library, are available in <<udt-generator>>.

====== Manual

Manual creation of custom Java classes implementing `java.sql.SQLData` is done fairly easily but also requires
manual updates when schema changes.

Given a UDT created with the following DDL:
[source,SQL]
----
include::{exdir}/udt/address.sql[]
----

A simple implementation of `java.sql.SQLData` is:
[source,java]
----
include::{exdir}/udt/Address.java[]
----
<1> Provides the custom type name this Java class maps to; the name can be schema qualified if necessary.
<2> `readSQL` reads the attributes in definition order.
<3> `writeSQL` writes the attributes in definition order.


IMPORTANT: The implementations of `readSQL` and `writeSQL` must always read and write attributes in the order
in which they were defined in the DDL statement. After DDL updates like `ALTER TYPE` this order isn't always
obvious and where using the <<udt-generator>> can help ensure correct implementation.


=== Arrays

While there are no special requirements beyond the standard JDBC API and `java.sql.Array` for accessing the
array types provided by {vendorname}, it is worth noting that {drivername} fully supports accessing arrays
of standard, extended and custom types.

=== Dates/Times

Prior to JDBC 4.2, `java.sql.Time`, `java.sql.Date` & `java.sql.Timestamp` were used to represent the associated
SQL datatypes in Java. These types have proven almost unwieldy when used in situations spanning timezones and
calendars.

JDBC 4.2 introduced supported for the new https://jcp.org/en/jsr/detail?id=310[Java Date and Time API (JSR 310)]
which are easy to use and provide consistent views of times and dates.

{drivername} not only fully implements this portion of the JDBC 4.2 specification, all of its Date/Time handling
is built on this library. Therefore it is suggested to skip using the JDBC Date/Time types when possible and
use the Date/Time API instead. It provides an easier to use API and the data undergoes less transformation to
arrive at a Java type.

Some simple examples are provided to detail the basic usage of JDBC with the new Date and Time API classes.
Although, to learn the full capabilities and usage of the new integration we suggest reading the relevant
portions of the JDBC API or any of the widely available tutorials.

==== Basic Usage

To retrieve values using the new Date and Time API you must _not_ use the convenience APIs named for their
counterpart datatype, and instead use `getObject` providing the type of object you would like to receive.

[source,java]
.Retrieve a LocalDateTime from a TIMESTAMP WITHOUT TIMEZONE
----
ResultSet rs = statement.getResultSet();
LocalDateTime incorrect = rs.getTimestamp(1).toLocalDateTime(); <1>
LocalDateTime correct = rs.getObjecct(1, LocalDateTime.class); <2>
----
<1> [red]#Incorrect method using convenience API and conversion#
<2> Correct method using `getObject` and no conversion.

Similarly setting values should provide the new Date and Time API object directly to the driver using
`setObject` and not use the convenience APIs.

[source,java]
.Providing LocalDateTime for a TIMESTAMP WITHOUT TIMEZONE
----
PreparedStatement stmt = conn.prepareStatement("INSERT INTO log VALUES (? , ?)");
stmt.setText("Something happened");
stmt.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now())); <1>
stmt.setObject(1, LocalDateTime.now()); <2>
----
<1> Incorrect method using convenience API and conversion
<2> Correct method using `setObject` and no conversion.

The preceding examples show usage of `LocalDateTime` but support for all of the new Date and Time API classes
is provided matching the applicable SQL datatypes as specified by JDBC.

WARNING: JDBC 4.2 does not specify support for `ZonedDateTime` in any fashion and {drivername} follows that
specification. `ZonedDateTime` must be converted to `OffsetDateTime` before begin passed to the API.
