package com.impossibl.postgres.jdbc;

import static com.impossibl.postgres.jdbc.ErrorUtils.chainWarnings;
import static com.impossibl.postgres.jdbc.Exceptions.INVALID_COMMAND_FOR_GENERATED_KEYS;
import static com.impossibl.postgres.jdbc.Exceptions.NOT_SUPPORTED;
import static com.impossibl.postgres.jdbc.SQLTextUtils.appendReturningClause;
import static java.util.Arrays.asList;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.util.Collections;

import com.impossibl.postgres.protocol.PrepareCommand;
import com.impossibl.postgres.protocol.ResultField;
import com.impossibl.postgres.types.Type;

class PGSimpleStatement extends PGStatement {

	public PGSimpleStatement(PGConnection connection, int type, int concurrency, int holdability) {
		super(connection, type, concurrency, holdability, 0, Collections.<ResultField>emptyList());
	}

	SQLWarning prepare(SQLText sqlText) throws SQLException {

		if(processEscapes) {
			SQLTextEscapes.processEscapes(sqlText, connection);
		}
		
		PrepareCommand prep = connection.getProtocol().createPrepare(0, sqlText.toString(), Collections.<Type>emptyList());
		
		SQLWarning warningChain = connection.execute(prep);
		
		resultFields = prep.getDescribedResultFields();
		
		return warningChain;
	}
	
	boolean execute(SQLText sqlText) throws SQLException {
		
		SQLWarning prepWarningChain = prepare(sqlText);
				
		boolean res = super.executeStatement(0, Collections.<Type>emptyList(), Collections.<Object>emptyList());
		
		warningChain = chainWarnings(prepWarningChain, warningChain);
		
		return res;
	}

	@Override
	public boolean execute(String sql) throws SQLException {

		SQLText sqlText = new SQLText(sql);
		
		return execute(sqlText);
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
		
		SQLText sqlText = new SQLText(sql);
		
		if(autoGeneratedKeys != RETURN_GENERATED_KEYS) {
			return execute(sqlText);
		}
		
		if(appendReturningClause(sqlText) == false) {
			throw INVALID_COMMAND_FOR_GENERATED_KEYS;
		}
		
		execute(sqlText);
		
		generatedKeysResultSet = getResultSet();
		
		return false;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {

		throw NOT_SUPPORTED;
	}

	@Override
	public boolean execute(String sql, String[] columnNames) throws SQLException {
		
		SQLText sqlText = new SQLText(sql);
		
		if(appendReturningClause(sqlText, asList(columnNames)) == false) {
			throw INVALID_COMMAND_FOR_GENERATED_KEYS;
		}
		
		execute(sqlText);
		
		generatedKeysResultSet = getResultSet();
		
		return false;
	}

	@Override
	public ResultSet executeQuery(String sql) throws SQLException {

		execute(sql);

		return getResultSet();
	}

	@Override
	public int executeUpdate(String sql) throws SQLException {
		
		execute(sql);
		
		return getUpdateCount();
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
		
		execute(sql, autoGeneratedKeys);
		
		return getUpdateCount();
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {

		execute(sql, columnIndexes);
		
		return getUpdateCount();
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames) throws SQLException {

		execute(sql, columnNames);
		
		return getUpdateCount();
	}

	@Override
	public void addBatch(String sql) throws SQLException {
		throw NOT_SUPPORTED;
	}

	@Override
	public void clearBatch() throws SQLException {
		throw NOT_SUPPORTED;
	}

	@Override
	public int[] executeBatch() throws SQLException {
		throw NOT_SUPPORTED;
	}

}
